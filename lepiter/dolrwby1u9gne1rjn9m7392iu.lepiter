{
	"__schema" : "4.1",
	"__type" : "page",
	"children" : {
		"__type" : "snippets",
		"items" : [
			{
				"__type" : "textSnippet",
				"children" : {
					"__type" : "snippets",
					"items" : [ ]
				},
				"createEmail" : {
					"__type" : "email",
					"emailString" : "<unknown>"
				},
				"createTime" : {
					"__type" : "time",
					"time" : {
						"__type" : "dateAndTime",
						"dateAndTimeString" : "2025-09-11T05:30:27.247653-05:00"
					}
				},
				"editEmail" : {
					"__type" : "email",
					"emailString" : "<unknown>"
				},
				"editTime" : {
					"__type" : "time",
					"time" : {
						"__type" : "dateAndTime",
						"dateAndTimeString" : "2025-09-11T10:48:26.538092-05:00"
					}
				},
				"uid" : {
					"__type" : "uid",
					"uidString" : "Nf48w+X6DQCKMlGiAFYh5w=="
				},
				"paragraphStyle" : {
					"__type" : "textStyle"
				},
				"string" : "Welcome to our sixth and latest installment of Six Simple Sudoku Solvers! In case you are new here, this is a series about building six different Sudoku solvers in six different programming languages. [Check the first part](https://blog.veitheller.de/Six_Simple_Sudoku_Solvers_I:_Python_(Reference).html) for more information on the algorithm as well as a reference implementation."
			},
			{
				"__type" : "textSnippet",
				"children" : {
					"__type" : "snippets",
					"items" : [ ]
				},
				"createEmail" : {
					"__type" : "email",
					"emailString" : "<unknown>"
				},
				"createTime" : {
					"__type" : "time",
					"time" : {
						"__type" : "dateAndTime",
						"dateAndTimeString" : "2025-09-13T20:56:28.976961-05:00"
					}
				},
				"editEmail" : {
					"__type" : "email",
					"emailString" : "<unknown>"
				},
				"editTime" : {
					"__type" : "time",
					"time" : {
						"__type" : "dateAndTime",
						"dateAndTimeString" : "2025-09-13T20:57:58.916036-05:00"
					}
				},
				"uid" : {
					"__type" : "uid",
					"uidString" : "GEeSNOr6DQCL9haVAFYh5w=="
				},
				"paragraphStyle" : {
					"__type" : "textStyle"
				},
				"string" : "For this last post, we’re going to focus on Elixir. Elixir is a language that runs on the BEAM, the virtual machine that powers Erlang, a language for massively parallel workloads originally built for telephony systems. Elixir is the newer, hipper cousin of that language, sporting a Ruby-like syntax."
			},
			{
				"__type" : "textSnippet",
				"children" : {
					"__type" : "snippets",
					"items" : [ ]
				},
				"createEmail" : {
					"__type" : "email",
					"emailString" : "<unknown>"
				},
				"createTime" : {
					"__type" : "time",
					"time" : {
						"__type" : "dateAndTime",
						"dateAndTimeString" : "2025-09-13T20:58:14.550503-05:00"
					}
				},
				"editEmail" : {
					"__type" : "email",
					"emailString" : "<unknown>"
				},
				"editTime" : {
					"__type" : "time",
					"time" : {
						"__type" : "dateAndTime",
						"dateAndTimeString" : "2025-09-13T20:59:29.229371-05:00"
					}
				},
				"uid" : {
					"__type" : "uid",
					"uidString" : "f+oc9Br7DQCdi0g8Dp1zVw=="
				},
				"paragraphStyle" : {
					"__type" : "textStyle"
				},
				"string" : "My goal is for us to build a parallel solver without even noticing; we’ll build the same algorithm we’ve built five times before now, and then just wave our hands and let Elixir take the wheel to make it parallel."
			},
			{
				"__type" : "textSnippet",
				"children" : {
					"__type" : "snippets",
					"items" : [ ]
				},
				"createEmail" : {
					"__type" : "email",
					"emailString" : "<unknown>"
				},
				"createTime" : {
					"__type" : "time",
					"time" : {
						"__type" : "dateAndTime",
						"dateAndTimeString" : "2025-09-13T20:59:21.117996-05:00"
					}
				},
				"editEmail" : {
					"__type" : "email",
					"emailString" : "<unknown>"
				},
				"editTime" : {
					"__type" : "time",
					"time" : {
						"__type" : "dateAndTime",
						"dateAndTimeString" : "2025-09-13T20:59:27.374485-05:00"
					}
				},
				"uid" : {
					"__type" : "uid",
					"uidString" : "Cxvr+Br7DQCkgxIrDp1zVw=="
				},
				"paragraphStyle" : {
					"__type" : "textStyle"
				},
				"string" : "## Why Elixir?"
			},
			{
				"__type" : "textSnippet",
				"children" : {
					"__type" : "snippets",
					"items" : [ ]
				},
				"createEmail" : {
					"__type" : "email",
					"emailString" : "<unknown>"
				},
				"createTime" : {
					"__type" : "time",
					"time" : {
						"__type" : "dateAndTime",
						"dateAndTimeString" : "2025-09-13T20:59:30.572542-05:00"
					}
				},
				"editEmail" : {
					"__type" : "email",
					"emailString" : "<unknown>"
				},
				"editTime" : {
					"__type" : "time",
					"time" : {
						"__type" : "dateAndTime",
						"dateAndTimeString" : "2025-09-13T21:28:43.716641-05:00"
					}
				},
				"uid" : {
					"__type" : "uid",
					"uidString" : "wl57+Rr7DQCk9VWpDp1zVw=="
				},
				"paragraphStyle" : {
					"__type" : "textStyle"
				},
				"string" : "Elixir is a pretty language to look at. It’s both approachable and powerful, and it can be (and is) used to solve real-world problems quickly and well. But since that doesn’t tell us very much yet, let’s look at some concrete language features that make Elixir interesting:"
			},
			{
				"__type" : "textSnippet",
				"children" : {
					"__type" : "snippets",
					"items" : [ ]
				},
				"createEmail" : {
					"__type" : "email",
					"emailString" : "<unknown>"
				},
				"createTime" : {
					"__type" : "time",
					"time" : {
						"__type" : "dateAndTime",
						"dateAndTimeString" : "2025-09-13T21:28:44.842015-05:00"
					}
				},
				"editEmail" : {
					"__type" : "email",
					"emailString" : "<unknown>"
				},
				"editTime" : {
					"__type" : "time",
					"time" : {
						"__type" : "dateAndTime",
						"dateAndTimeString" : "2025-09-13T22:15:42.462707-05:00"
					}
				},
				"uid" : {
					"__type" : "uid",
					"uidString" : "42MLYhv7DQCv5FgjDp1zVw=="
				},
				"paragraphStyle" : {
					"__type" : "textStyle"
				},
				"string" : "- **Effortless concurrency**. We can use the BEAM and its abstraction to spawn low-overhead threads and use messages passing to communicate between them (and is network-transparent!).\n- **The Open Telecom Platform (OTP)**. The OTP is, strictly speaking, the whole Erlang distribution, but nowadays more often than not refers to the extensive library of abstractions for parallel applications that Erlang (and thus Elixir) ships with. Servers, state management, monitoring, supervisors, and others are all readily available as components, and have proven quite robust over decades of use in anger.\n- **Excellent tooling and libraries**. Package management and build tooling through hex and mix, even documentation generation are all pleasurable experiences. And with modern frameworks such as Phoenix (a full-service web framework in the lineage of Ruby on Rails) working with Elixir feels not just productive but extremely ergonomic."
			},
			{
				"__type" : "textSnippet",
				"children" : {
					"__type" : "snippets",
					"items" : [ ]
				},
				"createEmail" : {
					"__type" : "email",
					"emailString" : "<unknown>"
				},
				"createTime" : {
					"__type" : "time",
					"time" : {
						"__type" : "dateAndTime",
						"dateAndTimeString" : "2025-09-13T21:36:46.393798-05:00"
					}
				},
				"editEmail" : {
					"__type" : "email",
					"emailString" : "<unknown>"
				},
				"editTime" : {
					"__type" : "time",
					"time" : {
						"__type" : "dateAndTime",
						"dateAndTimeString" : "2025-09-13T21:37:57.155144-05:00"
					}
				},
				"uid" : {
					"__type" : "uid",
					"uidString" : "cmUzfhv7DQCFTqowDp1zVw=="
				},
				"paragraphStyle" : {
					"__type" : "textStyle"
				},
				"string" : "Truth be told, we won’t be needing much of that today. What we will use is a convenient base language with effortless concurrency. And I think that’s more than enough!"
			},
			{
				"__type" : "textSnippet",
				"children" : {
					"__type" : "snippets",
					"items" : [ ]
				},
				"createEmail" : {
					"__type" : "email",
					"emailString" : "<unknown>"
				},
				"createTime" : {
					"__type" : "time",
					"time" : {
						"__type" : "dateAndTime",
						"dateAndTimeString" : "2025-09-13T21:58:21.563066-05:00"
					}
				},
				"editEmail" : {
					"__type" : "email",
					"emailString" : "<unknown>"
				},
				"editTime" : {
					"__type" : "time",
					"time" : {
						"__type" : "dateAndTime",
						"dateAndTimeString" : "2025-09-13T21:59:28.145158-05:00"
					}
				},
				"uid" : {
					"__type" : "uid",
					"uidString" : "0/vxyxv7DQC/nsMmDp1zVw=="
				},
				"paragraphStyle" : {
					"__type" : "textStyle"
				},
				"string" : "(Oh, and by the way, a Glamorous Toolkit package for it exists and I was able to write this blog post using real Elixir snippets!)"
			},
			{
				"__type" : "textSnippet",
				"children" : {
					"__type" : "snippets",
					"items" : [ ]
				},
				"createEmail" : {
					"__type" : "email",
					"emailString" : "<unknown>"
				},
				"createTime" : {
					"__type" : "time",
					"time" : {
						"__type" : "dateAndTime",
						"dateAndTimeString" : "2025-09-13T21:37:57.722089-05:00"
					}
				},
				"editEmail" : {
					"__type" : "email",
					"emailString" : "<unknown>"
				},
				"editTime" : {
					"__type" : "time",
					"time" : {
						"__type" : "dateAndTime",
						"dateAndTimeString" : "2025-09-13T21:38:03.444824-05:00"
					}
				},
				"uid" : {
					"__type" : "uid",
					"uidString" : "fK3/ghv7DQCKcEXjDp1zVw=="
				},
				"paragraphStyle" : {
					"__type" : "textStyle"
				},
				"string" : "## The implementation"
			},
			{
				"__type" : "textSnippet",
				"children" : {
					"__type" : "snippets",
					"items" : [ ]
				},
				"createEmail" : {
					"__type" : "email",
					"emailString" : "<unknown>"
				},
				"createTime" : {
					"__type" : "time",
					"time" : {
						"__type" : "dateAndTime",
						"dateAndTimeString" : "2025-09-13T21:38:03.714614-05:00"
					}
				},
				"editEmail" : {
					"__type" : "email",
					"emailString" : "<unknown>"
				},
				"editTime" : {
					"__type" : "time",
					"time" : {
						"__type" : "dateAndTime",
						"dateAndTimeString" : "2025-09-13T21:38:22.313262-05:00"
					}
				},
				"uid" : {
					"__type" : "uid",
					"uidString" : "Gxxbgxv7DQCK54ZWDp1zVw=="
				},
				"paragraphStyle" : {
					"__type" : "textStyle"
				},
				"string" : "You know the drill: outside in, main solver first, then specifics."
			},
			{
				"__type" : "textSnippet",
				"children" : {
					"__type" : "snippets",
					"items" : [ ]
				},
				"createEmail" : {
					"__type" : "email",
					"emailString" : "<unknown>"
				},
				"createTime" : {
					"__type" : "time",
					"time" : {
						"__type" : "dateAndTime",
						"dateAndTimeString" : "2025-09-13T21:38:24.870833-05:00"
					}
				},
				"editEmail" : {
					"__type" : "email",
					"emailString" : "<unknown>"
				},
				"editTime" : {
					"__type" : "time",
					"time" : {
						"__type" : "dateAndTime",
						"dateAndTimeString" : "2025-09-13T21:38:29.237076-05:00"
					}
				},
				"uid" : {
					"__type" : "uid",
					"uidString" : "F++dhBv7DQCMPwjhDp1zVw=="
				},
				"paragraphStyle" : {
					"__type" : "textStyle"
				},
				"string" : "### The main solver"
			},
			{
				"__type" : "textSnippet",
				"children" : {
					"__type" : "snippets",
					"items" : [ ]
				},
				"createEmail" : {
					"__type" : "email",
					"emailString" : "<unknown>"
				},
				"createTime" : {
					"__type" : "time",
					"time" : {
						"__type" : "dateAndTime",
						"dateAndTimeString" : "2025-09-13T21:41:47.222143-05:00"
					}
				},
				"editEmail" : {
					"__type" : "email",
					"emailString" : "<unknown>"
				},
				"editTime" : {
					"__type" : "time",
					"time" : {
						"__type" : "dateAndTime",
						"dateAndTimeString" : "2025-09-13T21:41:58.623346-05:00"
					}
				},
				"uid" : {
					"__type" : "uid",
					"uidString" : "cJCtkBv7DQCNyCz/Dp1zVw=="
				},
				"paragraphStyle" : {
					"__type" : "textStyle"
				},
				"string" : "This code should by now be familiar to you."
			},
			{
				"__type" : "elixirSnippet",
				"children" : {
					"__type" : "snippets",
					"items" : [ ]
				},
				"createEmail" : {
					"__type" : "email",
					"emailString" : "<unknown>"
				},
				"createTime" : {
					"__type" : "time",
					"time" : {
						"__type" : "dateAndTime",
						"dateAndTimeString" : "2025-09-13T21:38:35.675425-05:00"
					}
				},
				"editEmail" : {
					"__type" : "email",
					"emailString" : "<unknown>"
				},
				"editTime" : {
					"__type" : "time",
					"time" : {
						"__type" : "dateAndTime",
						"dateAndTimeString" : "2025-09-13T21:41:37.4697-05:00"
					}
				},
				"uid" : {
					"__type" : "uid",
					"uidString" : "g8lChRv7DQCMsFXtDp1zVw=="
				},
				"code" : "def solve(board) do\n  case propagate(board) do\n    {:error, :contradiction} -> {:error, :unsat}\n    {:ok, b} ->\n      if solved?(b) do\n        {:ok, b}\n      else\n        {{i, j}, cs} = find_mrv(b)\n\n        branch(b, i, j, cs)\n      end\n  end\nend"
			},
			{
				"__type" : "textSnippet",
				"children" : {
					"__type" : "snippets",
					"items" : [ ]
				},
				"createEmail" : {
					"__type" : "email",
					"emailString" : "<unknown>"
				},
				"createTime" : {
					"__type" : "time",
					"time" : {
						"__type" : "dateAndTime",
						"dateAndTimeString" : "2025-09-13T21:42:02.234335-05:00"
					}
				},
				"editEmail" : {
					"__type" : "email",
					"emailString" : "<unknown>"
				},
				"editTime" : {
					"__type" : "time",
					"time" : {
						"__type" : "dateAndTime",
						"dateAndTimeString" : "2025-09-13T21:43:41.979783-05:00"
					}
				},
				"uid" : {
					"__type" : "uid",
					"uidString" : "eaGSkRv7DQCOra8gDp1zVw=="
				},
				"paragraphStyle" : {
					"__type" : "textStyle"
				},
				"string" : "The only thing we might be looking at a little weirdly if this is our first time reading Elixir is the pattern matching, but even that’s pretty tame: `propagate` either gives us an error back and we in turn pass it to our caller, or we check whether things are solved, then find our best candidate and branch out. But how do we do that?"
			},
			{
				"__type" : "elixirSnippet",
				"children" : {
					"__type" : "snippets",
					"items" : [ ]
				},
				"createEmail" : {
					"__type" : "email",
					"emailString" : "<unknown>"
				},
				"createTime" : {
					"__type" : "time",
					"time" : {
						"__type" : "dateAndTime",
						"dateAndTimeString" : "2025-09-13T21:43:49.535679-05:00"
					}
				},
				"editEmail" : {
					"__type" : "email",
					"emailString" : "<unknown>"
				},
				"editTime" : {
					"__type" : "time",
					"time" : {
						"__type" : "dateAndTime",
						"dateAndTimeString" : "2025-09-13T21:49:57.744349-05:00"
					}
				},
				"uid" : {
					"__type" : "uid",
					"uidString" : "p+D3lxv7DQCWt2ZBDp1zVw=="
				},
				"code" : "defp branch(b, i, j, cs) do\n  cs\n  |> Task.async_stream(\n       fn v -> solve(put_cell(b, i, j, v)) end,\n       timeout: :infinity,\n       ordered: false\n     )\n  |> Enum.find_value(fn\n       {:ok, {:ok, s}} -> {:ok, s}\n       _ -> nil\n     end)\n  || {:error, :unsat}\nend"
			},
			{
				"__type" : "textSnippet",
				"children" : {
					"__type" : "snippets",
					"items" : [ ]
				},
				"createEmail" : {
					"__type" : "email",
					"emailString" : "<unknown>"
				},
				"createTime" : {
					"__type" : "time",
					"time" : {
						"__type" : "dateAndTime",
						"dateAndTimeString" : "2025-09-13T21:45:02.786588-05:00"
					}
				},
				"editEmail" : {
					"__type" : "email",
					"emailString" : "<unknown>"
				},
				"editTime" : {
					"__type" : "time",
					"time" : {
						"__type" : "dateAndTime",
						"dateAndTimeString" : "2025-09-13T21:47:51.183694-05:00"
					}
				},
				"uid" : {
					"__type" : "uid",
					"uidString" : "0KNVnBv7DQCXVvwfDp1zVw=="
				},
				"paragraphStyle" : {
					"__type" : "textStyle"
				},
				"string" : "That’s more like it, what are we doing here? We take our candidates, make a task that tries to solve all of them, and then either select the first one that returned a solution or return an error (`|>` and `||` are combinators here to help us chain streams and collections together)."
			},
			{
				"__type" : "textSnippet",
				"children" : {
					"__type" : "snippets",
					"items" : [ ]
				},
				"createEmail" : {
					"__type" : "email",
					"emailString" : "<unknown>"
				},
				"createTime" : {
					"__type" : "time",
					"time" : {
						"__type" : "dateAndTime",
						"dateAndTimeString" : "2025-09-13T21:47:55.402953-05:00"
					}
				},
				"editEmail" : {
					"__type" : "email",
					"emailString" : "<unknown>"
				},
				"editTime" : {
					"__type" : "time",
					"time" : {
						"__type" : "dateAndTime",
						"dateAndTimeString" : "2025-09-13T21:49:54.268476-05:00"
					}
				},
				"uid" : {
					"__type" : "uid",
					"uidString" : "So6fphv7DQCdzFBnDp1zVw=="
				},
				"paragraphStyle" : {
					"__type" : "textStyle"
				},
				"string" : "So already we got to the meat of this post: the concurrency. And it was incredibly simple, almost boring: we just called `Task.async_stream()` and it handled the rest for us. By specifying `ordered: false` we also ensure that we work on results as they come in and do not force an order, since we really don’t care which results come in first."
			},
			{
				"__type" : "textSnippet",
				"children" : {
					"__type" : "snippets",
					"items" : [ ]
				},
				"createEmail" : {
					"__type" : "email",
					"emailString" : "<unknown>"
				},
				"createTime" : {
					"__type" : "time",
					"time" : {
						"__type" : "dateAndTime",
						"dateAndTimeString" : "2025-09-13T21:50:15.20101-05:00"
					}
				},
				"editEmail" : {
					"__type" : "email",
					"emailString" : "<unknown>"
				},
				"editTime" : {
					"__type" : "time",
					"time" : {
						"__type" : "dateAndTime",
						"dateAndTimeString" : "2025-09-13T21:50:22.948465-05:00"
					}
				},
				"uid" : {
					"__type" : "uid",
					"uidString" : "ZqYHrhv7DQCncTbLDp1zVw=="
				},
				"paragraphStyle" : {
					"__type" : "textStyle"
				},
				"string" : "## Propagation"
			},
			{
				"__type" : "textSnippet",
				"children" : {
					"__type" : "snippets",
					"items" : [ ]
				},
				"createEmail" : {
					"__type" : "email",
					"emailString" : "<unknown>"
				},
				"createTime" : {
					"__type" : "time",
					"time" : {
						"__type" : "dateAndTime",
						"dateAndTimeString" : "2025-09-13T21:50:23.608748-05:00"
					}
				},
				"editEmail" : {
					"__type" : "email",
					"emailString" : "<unknown>"
				},
				"editTime" : {
					"__type" : "time",
					"time" : {
						"__type" : "dateAndTime",
						"dateAndTimeString" : "2025-09-13T21:50:35.82474-05:00"
					}
				},
				"uid" : {
					"__type" : "uid",
					"uidString" : "BQB1rxv7DQCn7Qu9Dp1zVw=="
				},
				"paragraphStyle" : {
					"__type" : "textStyle"
				},
				"string" : "Next up is propagation, the solver of boards."
			},
			{
				"__type" : "elixirSnippet",
				"children" : {
					"__type" : "snippets",
					"items" : [ ]
				},
				"createEmail" : {
					"__type" : "email",
					"emailString" : "<unknown>"
				},
				"createTime" : {
					"__type" : "time",
					"time" : {
						"__type" : "dateAndTime",
						"dateAndTimeString" : "2025-09-13T21:50:40.402022-05:00"
					}
				},
				"editEmail" : {
					"__type" : "email",
					"emailString" : "<unknown>"
				},
				"editTime" : {
					"__type" : "time",
					"time" : {
						"__type" : "dateAndTime",
						"dateAndTimeString" : "2025-09-13T21:52:03.082828-05:00"
					}
				},
				"uid" : {
					"__type" : "uid",
					"uidString" : "TT11sBv7DQCpBGcQDp1zVw=="
				},
				"code" : "defp propagate(board) do\n  {b2, changed, ok?} =\n    Enum.reduce(0..8, {board, false, true}, fn i, acc ->\n      Enum.reduce(0..8, acc, fn j, {b, ch, ok} ->\n        v = b |> Enum.at(i) |> Enum.at(j)\n\n        cond do\n          not ok -> {b, ch, false}\n          v != 0 -> {b, ch, ok}\n          true ->\n            cs = candidates(b, i, j)\n            cond do\n              cs == [] -> {b, ch, false}\n              length(cs) == 1 ->\n                {put_cell(b, i, j, hd(cs)), true, ok}\n              true -> {b, ch, ok}\n            end\n        end\n      end)\n    end)\n\n  cond do\n    not ok? -> {:error, :contradiction}\n    changed -> propagate(b2)\n    true    -> {:ok, b2}\n  end\nend"
			},
			{
				"__type" : "textSnippet",
				"children" : {
					"__type" : "snippets",
					"items" : [ ]
				},
				"createEmail" : {
					"__type" : "email",
					"emailString" : "<unknown>"
				},
				"createTime" : {
					"__type" : "time",
					"time" : {
						"__type" : "dateAndTime",
						"dateAndTimeString" : "2025-09-13T21:52:08.034407-05:00"
					}
				},
				"editEmail" : {
					"__type" : "email",
					"emailString" : "<unknown>"
				},
				"editTime" : {
					"__type" : "time",
					"time" : {
						"__type" : "dateAndTime",
						"dateAndTimeString" : "2025-09-13T22:16:32.823484-05:00"
					}
				},
				"uid" : {
					"__type" : "uid",
					"uidString" : "vGeutRv7DQCqFI5vDp1zVw=="
				},
				"paragraphStyle" : {
					"__type" : "textStyle"
				},
				"string" : "A little longer than the other propagation algorithms perhaps, but very simple. We formulate our nested sweep over the board as reductions, returning a new board and two flags as a result. The flags should be familiar by now, signifying change of the board in this pass as well as whether the board is still solvable."
			},
			{
				"__type" : "textSnippet",
				"children" : {
					"__type" : "snippets",
					"items" : [ ]
				},
				"createEmail" : {
					"__type" : "email",
					"emailString" : "<unknown>"
				},
				"createTime" : {
					"__type" : "time",
					"time" : {
						"__type" : "dateAndTime",
						"dateAndTimeString" : "2025-09-13T21:54:24.55738-05:00"
					}
				},
				"editEmail" : {
					"__type" : "email",
					"emailString" : "<unknown>"
				},
				"editTime" : {
					"__type" : "time",
					"time" : {
						"__type" : "dateAndTime",
						"dateAndTimeString" : "2025-09-13T21:56:44.764597-05:00"
					}
				},
				"uid" : {
					"__type" : "uid",
					"uidString" : "G5TRvRv7DQCxSAE+Dp1zVw=="
				},
				"paragraphStyle" : {
					"__type" : "textStyle"
				},
				"string" : "Inside the loop we access the value and go over our check: if we already have an inconsistent board or the value is already set, we just continue to the next cell. Otherwise, we get the candidates. If we don’t have any valid candidates, we mark the board as inconsistent. If there’s only one, we fill the board and mark it as changed. Otherwise we just continue to the next cell."
			},
			{
				"__type" : "textSnippet",
				"children" : {
					"__type" : "snippets",
					"items" : [ ]
				},
				"createEmail" : {
					"__type" : "email",
					"emailString" : "<unknown>"
				},
				"createTime" : {
					"__type" : "time",
					"time" : {
						"__type" : "dateAndTime",
						"dateAndTimeString" : "2025-09-13T21:56:28.912227-05:00"
					}
				},
				"editEmail" : {
					"__type" : "email",
					"emailString" : "<unknown>"
				},
				"editTime" : {
					"__type" : "time",
					"time" : {
						"__type" : "dateAndTime",
						"dateAndTimeString" : "2025-09-13T21:57:31.183704-05:00"
					}
				},
				"uid" : {
					"__type" : "uid",
					"uidString" : "ExE7xRv7DQC6TfoLDp1zVw=="
				},
				"paragraphStyle" : {
					"__type" : "textStyle"
				},
				"string" : "After the loop we return an error if we are inconsistent, propagate again (recursion, yay!) if we had a change, or return."
			},
			{
				"__type" : "textSnippet",
				"children" : {
					"__type" : "snippets",
					"items" : [ ]
				},
				"createEmail" : {
					"__type" : "email",
					"emailString" : "<unknown>"
				},
				"createTime" : {
					"__type" : "time",
					"time" : {
						"__type" : "dateAndTime",
						"dateAndTimeString" : "2025-09-13T21:57:32.026153-05:00"
					}
				},
				"editEmail" : {
					"__type" : "email",
					"emailString" : "<unknown>"
				},
				"editTime" : {
					"__type" : "time",
					"time" : {
						"__type" : "dateAndTime",
						"dateAndTimeString" : "2025-09-13T21:57:48.512797-05:00"
					}
				},
				"uid" : {
					"__type" : "uid",
					"uidString" : "YyL+yBv7DQC+IKcoDp1zVw=="
				},
				"paragraphStyle" : {
					"__type" : "textStyle"
				},
				"string" : "### Finding candidates"
			},
			{
				"__type" : "textSnippet",
				"children" : {
					"__type" : "snippets",
					"items" : [ ]
				},
				"createEmail" : {
					"__type" : "email",
					"emailString" : "<unknown>"
				},
				"createTime" : {
					"__type" : "time",
					"time" : {
						"__type" : "dateAndTime",
						"dateAndTimeString" : "2025-09-13T21:57:49.223852-05:00"
					}
				},
				"editEmail" : {
					"__type" : "email",
					"emailString" : "<unknown>"
				},
				"editTime" : {
					"__type" : "time",
					"time" : {
						"__type" : "dateAndTime",
						"dateAndTimeString" : "2025-09-13T21:58:00.283499-05:00"
					}
				},
				"uid" : {
					"__type" : "uid",
					"uidString" : "1osEyhv7DQC+kh76Dp1zVw=="
				},
				"paragraphStyle" : {
					"__type" : "textStyle"
				},
				"string" : "Alright, let’s find the candidates for propagation."
			},
			{
				"__type" : "elixirSnippet",
				"children" : {
					"__type" : "snippets",
					"items" : [ ]
				},
				"createEmail" : {
					"__type" : "email",
					"emailString" : "<unknown>"
				},
				"createTime" : {
					"__type" : "time",
					"time" : {
						"__type" : "dateAndTime",
						"dateAndTimeString" : "2025-09-13T21:58:04.169338-05:00"
					}
				},
				"editEmail" : {
					"__type" : "email",
					"emailString" : "<unknown>"
				},
				"editTime" : {
					"__type" : "time",
					"time" : {
						"__type" : "dateAndTime",
						"dateAndTimeString" : "2025-09-13T22:01:20.195452-05:00"
					}
				},
				"uid" : {
					"__type" : "uid",
					"uidString" : "xJLoyhv7DQC/lfQUDp1zVw=="
				},
				"code" : "defp row(b, i), do: Enum.at(b, i)\ndefp col(b, j), do: Enum.map(b, &Enum.at(&1, j))\n\ndefp box(b, i, j) do\n  r0 = div(i, 3) * 3\n  c0 = div(j, 3) * 3\n  for r <- r0..(r0 + 2), c <- c0..(c0 + 2), do: b |> Enum.at(r) |> Enum.at(c)\nend\n\rdefp candidates(b, i, j) do\n  used =\n    MapSet.new(row(b, i) ++ col(b, j) ++ box(b, i, j))\n    |> MapSet.delete(0)\n\n  MapSet.to_list(MapSet.difference(@digits, used))\rend"
			},
			{
				"__type" : "textSnippet",
				"children" : {
					"__type" : "snippets",
					"items" : [ ]
				},
				"createEmail" : {
					"__type" : "email",
					"emailString" : "<unknown>"
				},
				"createTime" : {
					"__type" : "time",
					"time" : {
						"__type" : "dateAndTime",
						"dateAndTimeString" : "2025-09-13T22:01:23.54538-05:00"
					}
				},
				"editEmail" : {
					"__type" : "email",
					"emailString" : "<unknown>"
				},
				"editTime" : {
					"__type" : "time",
					"time" : {
						"__type" : "dateAndTime",
						"dateAndTimeString" : "2025-09-13T22:02:14.604458-05:00"
					}
				},
				"uid" : {
					"__type" : "uid",
					"uidString" : "nl1p0Bv7DQCC0dF3Dp1zVw=="
				},
				"paragraphStyle" : {
					"__type" : "textStyle"
				},
				"string" : "Honestly, thanks to pretty good abstractions this code is pretty boring! We make a set of all the row, column, and box values, delete 0, and get the difference from all possible digits."
			},
			{
				"__type" : "textSnippet",
				"children" : {
					"__type" : "snippets",
					"items" : [ ]
				},
				"createEmail" : {
					"__type" : "email",
					"emailString" : "<unknown>"
				},
				"createTime" : {
					"__type" : "time",
					"time" : {
						"__type" : "dateAndTime",
						"dateAndTimeString" : "2025-09-13T22:02:16.060442-05:00"
					}
				},
				"editEmail" : {
					"__type" : "email",
					"emailString" : "<unknown>"
				},
				"editTime" : {
					"__type" : "time",
					"time" : {
						"__type" : "dateAndTime",
						"dateAndTimeString" : "2025-09-13T22:18:05.170927-05:00"
					}
				},
				"uid" : {
					"__type" : "uid",
					"uidString" : "bCLs2Rv7DQCHgJVjDp1zVw=="
				},
				"paragraphStyle" : {
					"__type" : "textStyle"
				},
				"string" : "The box calculation is the only one that looks a bit funky for uninitiated eyes, presumably, but it is just a `for` list comprehension (with two generators) that collects all values by going through the rows and columns (think of it as a list comprehension that does a Cartesian product). The syntax might be a bit daunting at first, but I encourage you to split it up by commas and see whether you can decipher the individual expressions and go from there!"
			},
			{
				"__type" : "textSnippet",
				"children" : {
					"__type" : "snippets",
					"items" : [ ]
				},
				"createEmail" : {
					"__type" : "email",
					"emailString" : "<unknown>"
				},
				"createTime" : {
					"__type" : "time",
					"time" : {
						"__type" : "dateAndTime",
						"dateAndTimeString" : "2025-09-13T22:04:11.80473-05:00"
					}
				},
				"editEmail" : {
					"__type" : "email",
					"emailString" : "<unknown>"
				},
				"editTime" : {
					"__type" : "time",
					"time" : {
						"__type" : "dateAndTime",
						"dateAndTimeString" : "2025-09-13T22:04:59.229406-05:00"
					}
				},
				"uid" : {
					"__type" : "uid",
					"uidString" : "rUTS4Bv7DQCLSXtNDp1zVw=="
				},
				"paragraphStyle" : {
					"__type" : "textStyle"
				},
				"string" : "## MRV selection"
			},
			{
				"__type" : "textSnippet",
				"children" : {
					"__type" : "snippets",
					"items" : [ ]
				},
				"createEmail" : {
					"__type" : "email",
					"emailString" : "<unknown>"
				},
				"createTime" : {
					"__type" : "time",
					"time" : {
						"__type" : "dateAndTime",
						"dateAndTimeString" : "2025-09-13T22:04:59.667507-05:00"
					}
				},
				"editEmail" : {
					"__type" : "email",
					"emailString" : "<unknown>"
				},
				"editTime" : {
					"__type" : "time",
					"time" : {
						"__type" : "dateAndTime",
						"dateAndTimeString" : "2025-09-13T22:05:13.896143-05:00"
					}
				},
				"uid" : {
					"__type" : "uid",
					"uidString" : "kY+s4xv7DQCO5YXdDp1zVw=="
				},
				"paragraphStyle" : {
					"__type" : "textStyle"
				},
				"string" : "The last piece of our puzzle: selecting candidates for our search."
			},
			{
				"__type" : "elixirSnippet",
				"children" : {
					"__type" : "snippets",
					"items" : [ ]
				},
				"createEmail" : {
					"__type" : "email",
					"emailString" : "<unknown>"
				},
				"createTime" : {
					"__type" : "time",
					"time" : {
						"__type" : "dateAndTime",
						"dateAndTimeString" : "2025-09-13T22:05:17.547511-05:00"
					}
				},
				"editEmail" : {
					"__type" : "email",
					"emailString" : "<unknown>"
				},
				"editTime" : {
					"__type" : "time",
					"time" : {
						"__type" : "dateAndTime",
						"dateAndTimeString" : "2025-09-13T22:05:41.261969-05:00"
					}
				},
				"uid" : {
					"__type" : "uid",
					"uidString" : "hma95Bv7DQCQPdkGDp1zVw=="
				},
				"code" : "defp find_mrv(b) do\n  opts =\n    for i <- 0..8, j <- 0..8, Enum.at(Enum.at(b, i), j) == 0 do\n      cs = candidates(b, i, j)\n      {{i, j}, cs}\n    end\n\n  Enum.min_by(opts, fn {_pos, cs} -> length(cs) end)\nend"
			},
			{
				"__type" : "textSnippet",
				"children" : {
					"__type" : "snippets",
					"items" : [ ]
				},
				"createEmail" : {
					"__type" : "email",
					"emailString" : "<unknown>"
				},
				"createTime" : {
					"__type" : "time",
					"time" : {
						"__type" : "dateAndTime",
						"dateAndTimeString" : "2025-09-13T22:05:44.361615-05:00"
					}
				},
				"editEmail" : {
					"__type" : "email",
					"emailString" : "<unknown>"
				},
				"editTime" : {
					"__type" : "time",
					"time" : {
						"__type" : "dateAndTime",
						"dateAndTimeString" : "2025-09-13T22:07:15.451126-05:00"
					}
				},
				"uid" : {
					"__type" : "uid",
					"uidString" : "LZNW5hv7DQCQm+ONDp1zVw=="
				},
				"paragraphStyle" : {
					"__type" : "textStyle"
				},
				"string" : "Since we can just re-use our candidates code right above, all we have to do is collect all candidates and get the minimum, and we’re done with both MRV and the solver at large!"
			},
			{
				"__type" : "textSnippet",
				"children" : {
					"__type" : "snippets",
					"items" : [ ]
				},
				"createEmail" : {
					"__type" : "email",
					"emailString" : "<unknown>"
				},
				"createTime" : {
					"__type" : "time",
					"time" : {
						"__type" : "dateAndTime",
						"dateAndTimeString" : "2025-09-13T22:07:16.069283-05:00"
					}
				},
				"editEmail" : {
					"__type" : "email",
					"emailString" : "<unknown>"
				},
				"editTime" : {
					"__type" : "time",
					"time" : {
						"__type" : "dateAndTime",
						"dateAndTimeString" : "2025-09-13T22:07:18.125899-05:00"
					}
				},
				"uid" : {
					"__type" : "uid",
					"uidString" : "Re3N6xv7DQCV+HjaDp1zVw=="
				},
				"paragraphStyle" : {
					"__type" : "textStyle"
				},
				"string" : "## Fin"
			},
			{
				"__type" : "textSnippet",
				"children" : {
					"__type" : "snippets",
					"items" : [ ]
				},
				"createEmail" : {
					"__type" : "email",
					"emailString" : "<unknown>"
				},
				"createTime" : {
					"__type" : "time",
					"time" : {
						"__type" : "dateAndTime",
						"dateAndTimeString" : "2025-09-13T22:07:24.936688-05:00"
					}
				},
				"editEmail" : {
					"__type" : "email",
					"emailString" : "<unknown>"
				},
				"editTime" : {
					"__type" : "time",
					"time" : {
						"__type" : "dateAndTime",
						"dateAndTimeString" : "2025-09-13T22:10:21.275761-05:00"
					}
				},
				"uid" : {
					"__type" : "uid",
					"uidString" : "4Obz6xv7DQCWGlMyDp1zVw=="
				},
				"paragraphStyle" : {
					"__type" : "textStyle"
				},
				"string" : "Even if you didn’t notice, we wrote a parallelized version of our solver in Elixir today! If it felt like revisiting Part I, this is no accident! I wanted to show you how with the right tools, parallelization and concurrency don’t have to be a pain. To be fair, our workload today was about as trivial as things can be, but let me assure you that Elixir can handle most difficult cases gracefully."
			},
			{
				"__type" : "textSnippet",
				"children" : {
					"__type" : "snippets",
					"items" : [ ]
				},
				"createEmail" : {
					"__type" : "email",
					"emailString" : "<unknown>"
				},
				"createTime" : {
					"__type" : "time",
					"time" : {
						"__type" : "dateAndTime",
						"dateAndTimeString" : "2025-09-13T22:10:23.841208-05:00"
					}
				},
				"editEmail" : {
					"__type" : "email",
					"emailString" : "<unknown>"
				},
				"editTime" : {
					"__type" : "time",
					"time" : {
						"__type" : "dateAndTime",
						"dateAndTimeString" : "2025-09-13T22:11:22.706029-05:00"
					}
				},
				"uid" : {
					"__type" : "uid",
					"uidString" : "oRf/9hv7DQCjq0ohDp1zVw=="
				},
				"paragraphStyle" : {
					"__type" : "textStyle"
				},
				"string" : "More than that, though, this brings our series to a close. We laughed, we cried, we puzzled, and you’ve been the best audience I could hope for! See you around, maybe for another season (I already have many more languages in mind!)."
			}
		]
	},
	"createEmail" : {
		"__type" : "email",
		"emailString" : "<unknown>"
	},
	"createTime" : {
		"__type" : "time",
		"time" : {
			"__type" : "dateAndTime",
			"dateAndTimeString" : "2025-09-11T05:30:37.663801-05:00"
		}
	},
	"editEmail" : {
		"__type" : "email",
		"emailString" : "<unknown>"
	},
	"editTime" : {
		"__type" : "time",
		"time" : {
			"__type" : "dateAndTime",
			"dateAndTimeString" : "2025-09-11T05:30:37.663801-05:00"
		}
	},
	"pageType" : {
		"__type" : "namedPage",
		"title" : "Six Simple Sudoku Solvers VI: Elixir"
	},
	"uid" : {
		"__type" : "uuid",
		"uuid" : "06743cc3-e5fa-0d00-8a31-e947005621e7"
	}
}